% Generated by MATLAB(R) 9.13 (R2022b) and Sensor Fusion and Tracking Toolbox 2.4 (R2022b).
% Generated on: 11-Oct-2022 12:00:26

tic

%Create hex mesh
scale = 34.641016151377531741097853660240657828156662760086052142215113918;
rad3over2 = (sqrt(3)/2);
[X, Y] = meshgrid(0:1:5);
n = size(X,1);
X = rad3over2 * X;
Y = Y + repmat([0 0.5], [n,n/2]);
%scale to make edge length = 40
X = scale*X;
Y=scale*Y;

%returns vertices of edges, each column is an edge
[XV, YV] = voronoi(X(:),Y(:));
plot(XV,YV,'r-')
axis equal
axis([0 160 0 180])
zoom on

hex_label = 0;
for i  = 1:n
    for j =1:n
        hex_label = hex_label +1;
        %inserts text on graph
        text(X(i,j),Y(i,j),int2str(hex_label),'HorizontalAlignment','center')        
    end
end

for i = 1:1
    
    clear scenario;
    clear attribute_vec;
    RunTime = 30;
    scenario = createScenario(RunTime);
    attribute_vec = zeros(RunTime*10,9);
    attackIntention = zeros(1,3);
    CellData = zeros(RunTime*10,1);
    WhileIndex = 1;
    ProbabilityIndex = [60 120 180 240 300 360];
    %[P60 P120 P180 P240 P300 P360] = 

    [tp, platp, detp, covp] = createPlotters();
    
    % Configure your tracker here:
    
    % Add a trackPlotter here:
    
    % Main simulation loop
    while advance(scenario) && ishghandle(tp.Parent)

      
        % generate sensor data
        [dets, configs, sensorConfigPIDs] = detect(scenario);
        
        [truePosition, meas, measCov, e, velocity] = readData(scenario, dets);
        
       
        %angle bw 2 vectors a & b is inverse cos (a dot b / mag(a) * mag(b))
        PlanePosition = truePosition(1,:);
        Tower1Pos = truePosition(2,:);
        Tower2Pos = truePosition(3,:);
        Tower3Pos = truePosition(4,:);
        index = 0;
        CellData(WhileIndex) = HexGrid(X,Y,[truePosition(1,1),truePosition(1,2)]);

        if WhileIndex ~= 1
            normTower = norm(truePosition(1,:)-truePosition(2,:));
            a = [Tower1Pos(1,2)-PlanePosition(1,2),Tower1Pos(1,1)-PlanePosition(1,1),0];
            b = [PlanePosition(1,2)-attribute_vec(WhileIndex-1,2),PlanePosition(1,1)-attribute_vec(WhileIndex-1,1),0];
            attackTheta2 = acosd((dot(a,b))/(norm(a)*norm(b)));
            attackIntention(1) = norm(velocity)*cosd(attackTheta2)/normTower;

            normTower = norm(truePosition(1,:)-truePosition(3,:));
            a = [Tower2Pos(1,2)-PlanePosition(1,2),Tower2Pos(1,1)-PlanePosition(1,1),0];
            b = [PlanePosition(1,2)-attribute_vec(WhileIndex-1,2),PlanePosition(1,1)-attribute_vec(WhileIndex-1,1),0];
            attackTheta2 = acosd((dot(a,b))/(norm(a)*norm(b)));
            attackIntention(2) = norm(velocity)*cosd(attackTheta2)/normTower;

            normTower = norm(truePosition(1,:)-truePosition(4,:));
            a = [Tower3Pos(1,2)-PlanePosition(1,2),Tower3Pos(1,1)-PlanePosition(1,1),0];
            b = [PlanePosition(1,2)-attribute_vec(WhileIndex-1,2),PlanePosition(1,1)-attribute_vec(WhileIndex-1,1),0];
            attackTheta2 = acosd((dot(a,b))/(norm(a)*norm(b)));
            attackIntention(3) = norm(velocity)*cosd(attackTheta2)/normTower;
            
            if CellData(WhileIndex) - CellData(WhileIndex -1) ~= 0
                pointer = 1;
                first_pt = zeros(1,2);
                second_pt = zeros(1,2);
                for i  = 1:n
                    for j =1:n
                        if pointer == CellData(WhileIndex)
                            second_pt = [X(i,j),Y(i,j)];
                        end
                        pointer= pointer +1;
                       
                    end
                end
                
                pointer = 1;
                for i  = 1:n
                    for j =1:n
                        if pointer == CellData(WhileIndex-1)
                            first_pt = [X(i,j),Y(i,j)];
                        end
                        pointer= pointer +1;        
                    end
                end

               slope =  (second_pt(2)-first_pt(2))/(second_pt(1)-first_pt(1));
               direction = atand(slope);

            end
        
        end 
        

        attribute_vec(WhileIndex,:) = [index,CellData(WhileIndex),truePosition(1,:),e(1,3),attackIntention];
        WhileIndex = WhileIndex +1;
        % update your tracker here:
        
        % update plots
%         plotPlatform(platp,truePosition);
%         plotDetection(detp,meas,measCov);
%         plotCoverage(covp,coverageConfig(scenario));
        
        % Update the trackPlotter here:
        
%         drawnow
    end
    writematrix(attribute_vec,sprintf('C:/Users/i_maa/Desktop/Thesis/Data/atrribute_vec%u.csv', i)); 
    %writematrix(eulerangles,sprintf('eulerangles_%u.csv', i)); 

end
toc

function [position, meas, measCov, eulerang,velocity] = readData(scenario,dets)
allDets = [dets{:}];

if ~isempty(allDets)
    % extract column vector of measurement positions
    meas = cat(2,allDets.Measurement)';

    % extract measurement noise
    measCov = cat(3,allDets.MeasurementNoise);
else
    meas = zeros(0,3);
    measCov = zeros(3,3,0);
end

truePoses = platformPoses(scenario);
position = vertcat(truePoses(:).Position);
velocity = truePoses(1,:).Velocity;
eulerang = eulerd(truePoses(1).Orientation, 'XYZ', 'frame');

end


function [tp, platp, detp, covp] = createPlotters
% Create plotters
tp = theaterPlot('XLim', [-19.0499952293663 73.1702865541693], 'YLim', [-63.3323407980601 28.8879409854753], 'ZLim', [-86.0323407980601 6.18794098547532]);
set(tp.Parent,'YDir','reverse', 'ZDir','reverse');
view(tp.Parent, -37.5, 30);
platp = platformPlotter(tp,'DisplayName','Platforms','MarkerFaceColor','k');
detp = detectionPlotter(tp,'DisplayName','Detections','MarkerSize',6,'MarkerFaceColor',[0.85 0.325 0.098],'MarkerEdgeColor','k','History',10000);
covp = coveragePlotter(tp,'DisplayName','Sensor Coverage');
end


function scenario = createScenario(RunTime)
% Create Scenario
rng('shuffle');

NumberofWaypoints = 5;
waypoints = Waypoints_YawAngle(NumberofWaypoints);
timearray = TOA(waypoints, RunTime);

scenario = trackingScenario;
scenario.StopTime = Inf;
scenario.UpdateRate = 0;


% Create platforms
Plane = platform(scenario,'ClassID',1);
Plane.Dimensions = struct( ...
    'Length', 1, ...
    'Width', 1, ...
    'Height', 1, ...
    'OriginOffset', [0 0 0]);
Plane.Signatures = {...
    rcsSignature(...
        'FluctuationModel', 'Swerling0', ...
        'Pattern', [20 20;20 20], ...
        'Azimuth', [-180 180], ...
        'Elevation', [-90;90], ...
        'Frequency', [0 1e+20])};
Plane.Trajectory = waypointTrajectory( ...
    waypoints, ...
    timearray, ...
    'ClimbRate', zeros(1,NumberofWaypoints), ...
    'AutoPitch', true, ...
    'AutoBank', true);

Tower = platform(scenario,'ClassID',3);
Tower.Dimensions = struct( ...
    'Length', 10, ...
    'Width', 10, ...
    'Height', 60, ...
    'OriginOffset', [0 0 30]);
Tower.Trajectory.Position = [140, 70,0];

Tower = platform(scenario,'ClassID',4);
Tower.Dimensions = struct( ...
    'Length', 10, ...
    'Width', 10, ...
    'Height', 60, ...
    'OriginOffset', [0 0 30]);
Tower.Trajectory.Position = [110, 120,0];   

Tower = platform(scenario,'ClassID',5);
Tower.Dimensions = struct( ...
    'Length', 10, ...
    'Width', 10, ...
    'Height', 60, ...
    'OriginOffset', [0 0 30]);
Tower.Trajectory.Position = [140, 90,0];

% Create sensors
Rotator = fusionRadarSensor('SensorIndex', 1, ...
    'UpdateRate', 10, ...
    'MountingLocation', [0 -0.06 0], ...
    'FieldOfView', [1 10], ...
    'HasINS', true, ...
    'DetectionCoordinates', 'Scenario');


% Assign sensors to platforms
Plane.Sensors = Rotator;
end
