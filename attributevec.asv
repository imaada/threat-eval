% Generated by MATLAB(R) 9.13 (R2022b) and Sensor Fusion and Tracking Toolbox 2.4 (R2022b).
% Generated on: 11-Oct-2022 12:00:26

tic

for i = 1:1
    
    clear scenario;
    clear attribute_vec;
    RunTime = 30;
    scenario = createScenario(RunTime);
    attribute_vec = zeros(RunTime*10,8);
    attackIntention = zeros(1,3);
    WhileIndex = 1;

    [tp, platp, detp, covp] = createPlotters();
    
    % Configure your tracker here:
    
    % Add a trackPlotter here:
    
    % Main simulation loop
    while advance(scenario) && ishghandle(tp.Parent)

      
        % generate sensor data
        [dets, configs, sensorConfigPIDs] = detect(scenario);
        
        [truePosition, meas, measCov, e, velocity] = readData(scenario, dets);
        
        %eulerangles(WhileIndex,:) = [e];
       
        %angle bw 2 vectors a & b is inverse cos (a dot b / mag(a) * mag(b))
           Tower1Pos = truePosition(2,:);
           Tower2Pos = truePosition(3,:);
           Tower3Pos = truePosition(4,:);
        if WhileIndex ~= 1
            normTower = norm(truePosition(1,:)-truePosition(2,:));
            a = [Tower1Pos(1,2)-PlanePosition(1,2),Tower1Pos(1,1)-PlanePosition(1,1),0];
            b = [PlanePosition(1,2)-attribute_vec(WhileIndex-1,2),PlanePosition(1,1)-attribute_vec(WhileIndex-1,1),0];
            attackTheta2 = acosd((dot(a,b))/(norm(a)*norm(b)));
            attackIntention(1) = norm(velocity)*cosd(attackTheta2)/normTower;

            normTower = norm(truePosition(1,:)-truePosition(3,:));
            a = [Tower2Pos(1,2)-PlanePosition(1,2),Tower2Pos(1,1)-PlanePosition(1,1),0];
            b = [PlanePosition(1,2)-attribute_vec(WhileIndex-1,2),PlanePosition(1,1)-attribute_vec(WhileIndex-1,1),0];
            attackTheta2 = acosd((dot(a,b))/(norm(a)*norm(b)));
            attackIntention(2) = norm(velocity)*cosd(attackTheta2)/normTower;

            normTower = norm(truePosition(1,:)-truePosition(4,:));
            a = [Tower3Pos(1,2)-PlanePosition(1,2),Tower3Pos(1,1)-PlanePosition(1,1),0];
            b = [PlanePosition(1,2)-attribute_vec(WhileIndex-1,2),PlanePosition(1,1)-attribute_vec(WhileIndex-1,1),0];
            attackTheta2 = acosd((dot(a,b))/(norm(a)*norm(b)));
            attackIntention(3) = norm(velocity)*cosd(attackTheta2)/normTower;
        
        end 
        attribute_vec(WhileIndex,:) = [HexGrid([]),truePosition(1,:),e(1,3),attackIntention];

        WhileIndex = WhileIndex +1;
        % update your tracker here:
        
        % update plots
%         plotPlatform(platp,truePosition);
%         plotDetection(detp,meas,measCov);
%         plotCoverage(covp,coverageConfig(scenario));
        
        % Update the trackPlotter here:
        
%         drawnow
    end
    writematrix(attribute_vec,sprintf('C:/Users/i_maa/Desktop/Thesis/Data/atrribute_vec%u.csv', i)); 
    %writematrix(eulerangles,sprintf('eulerangles_%u.csv', i)); 

end
toc

function [position, meas, measCov, eulerang,velocity] = readData(scenario,dets)
allDets = [dets{:}];

if ~isempty(allDets)
    % extract column vector of measurement positions
    meas = cat(2,allDets.Measurement)';

    % extract measurement noise
    measCov = cat(3,allDets.MeasurementNoise);
else
    meas = zeros(0,3);
    measCov = zeros(3,3,0);
end

truePoses = platformPoses(scenario);
position = vertcat(truePoses(:).Position);
velocity = truePoses(1,:).Velocity;
eulerang = eulerd(truePoses(1).Orientation, 'XYZ', 'frame');

end


function [tp, platp, detp, covp] = createPlotters
% Create plotters
tp = theaterPlot('XLim', [-19.0499952293663 73.1702865541693], 'YLim', [-63.3323407980601 28.8879409854753], 'ZLim', [-86.0323407980601 6.18794098547532]);
set(tp.Parent,'YDir','reverse', 'ZDir','reverse');
view(tp.Parent, -37.5, 30);
platp = platformPlotter(tp,'DisplayName','Platforms','MarkerFaceColor','k');
detp = detectionPlotter(tp,'DisplayName','Detections','MarkerSize',6,'MarkerFaceColor',[0.85 0.325 0.098],'MarkerEdgeColor','k','History',10000);
covp = coveragePlotter(tp,'DisplayName','Sensor Coverage');
end


function scenario = createScenario(RunTime)
% Create Scenario
rng('shuffle');

NumberofWaypoints = 5;
waypoints = Waypoints_YawAngle(NumberofWaypoints);
timearray = TOA(waypoints, RunTime);

scenario = trackingScenario;
scenario.StopTime = Inf;
scenario.UpdateRate = 0;


% Create platforms
Plane = platform(scenario,'ClassID',1);
Plane.Dimensions = struct( ...
    'Length', 1, ...
    'Width', 1, ...
    'Height', 1, ...
    'OriginOffset', [0 0 0]);
Plane.Signatures = {...
    rcsSignature(...
        'FluctuationModel', 'Swerling0', ...
        'Pattern', [20 20;20 20], ...
        'Azimuth', [-180 180], ...
        'Elevation', [-90;90], ...
        'Frequency', [0 1e+20])};
Plane.Trajectory = waypointTrajectory( ...
    waypoints, ...
    timearray, ...
    'ClimbRate', zeros(1,NumberofWaypoints), ...
    'AutoPitch', true, ...
    'AutoBank', true);

Tower = platform(scenario,'ClassID',3);
Tower.Dimensions = struct( ...
    'Length', 10, ...
    'Width', 10, ...
    'Height', 60, ...
    'OriginOffset', [0 0 30]);
Tower.Trajectory.Position = [140, 70,0];

Tower = platform(scenario,'ClassID',4);
Tower.Dimensions = struct( ...
    'Length', 10, ...
    'Width', 10, ...
    'Height', 60, ...
    'OriginOffset', [0 0 30]);
Tower.Trajectory.Position = [110, 120,0];   

Tower = platform(scenario,'ClassID',5);
Tower.Dimensions = struct( ...
    'Length', 10, ...
    'Width', 10, ...
    'Height', 60, ...
    'OriginOffset', [0 0 30]);
Tower.Trajectory.Position = [140, 90,0];

% Create sensors
Rotator = fusionRadarSensor('SensorIndex', 1, ...
    'UpdateRate', 10, ...
    'MountingLocation', [0 -0.06 0], ...
    'FieldOfView', [1 10], ...
    'HasINS', true, ...
    'DetectionCoordinates', 'Scenario');


% Assign sensors to platforms
Plane.Sensors = Rotator;
end
